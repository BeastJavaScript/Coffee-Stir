// Generated by CoffeeScript 1.7.1
var Include, List, Stacker,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Include = (function() {
  function Include(required, caller) {
    this.required = required;
    this.caller = caller;
  }

  return Include;

})();

if ((typeof module !== "undefined" && module !== null) && (module.exports != null)) {
  module.exports.Include = Include;
}


/*
  This class is to compile the Stacked Parser Files
 */

Stacker = (function() {

  /*
    @property includes [Array<Parser>,Parser] This is the parser files that need to be included
   */
  function Stacker() {
    var inc, includes, _i, _len;
    includes = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (includes instanceof Array) {
      for (_i = 0, _len = includes.length; _i < _len; _i++) {
        inc = includes[_i];
        this.includes = includes;
      }
    }
  }

  Stacker.prototype.includes = [];

  Stacker.prototype.addIncludes = function(more) {
    var file, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = more.length; _i < _len; _i++) {
      file = more[_i];
      _results.push(this.includes.push(file));
    }
    return _results;
  };

  Stacker.prototype.stack = function() {
    var include, list, _i, _len, _ref, _results;
    list = new List();
    _ref = this.includes;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      include = _ref[_i];
      _results.push(list.append(include));
    }
    return _results;
  };

  return Stacker;

})();

if ((typeof module !== "undefined" && module !== null) && (module.exports != null)) {
  module.exports.Stacker = Stacker;
}

List = (function() {
  function List() {
    this.collection = [];
  }

  List.prototype.append = function() {
    var item, parser, _i, _len;
    parser = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    for (_i = 0, _len = parser.length; _i < _len; _i++) {
      item = parser[_i];
      if (item instanceof Stacker) {
        this.appendStack(item);
      } else if (item instanceof Include) {
        this.appendInclude(item);
      }
    }
    console.log("______________BUILD_________________");
    console.log(this.collection);
    console.log("====================================");
    return this.build();
  };

  List.prototype.appendStack = function(stack) {
    var inc, _i, _len, _ref, _results;
    _ref = stack.includes;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      inc = _ref[_i];
      _results.push(this.appendInclude(inc));
    }
    return _results;
  };

  List.prototype.appendInclude = function(include) {
    return this.collection.push(include);
  };

  List.prototype.build = function() {
    var b, bronze, g, gold, inc, s, silver, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1;
    this.graph = [];
    bronze = [];
    silver = [];
    gold = [];
    _ref = this.collection;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      inc = _ref[_i];
      bronze.push(inc.caller);
    }
    _ref1 = this.collection;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      inc = _ref1[_j];
      silver.push(inc.required);
    }
    for (_k = 0, _len2 = silver.length; _k < _len2; _k++) {
      g = silver[_k];
      if (__indexOf.call(bronze, g) < 0) {
        gold.push(g);
      }
    }
    for (_l = 0, _len3 = bronze.length; _l < _len3; _l++) {
      b = bronze[_l];
      this.graph.push(b);
    }
    for (_m = 0, _len4 = silver.length; _m < _len4; _m++) {
      s = silver[_m];
      this.graph.push(s);
    }
    for (_n = 0, _len5 = gold.length; _n < _len5; _n++) {
      g = gold[_n];
      this.graph.push(g);
    }
    this.filter();
    return console.log(this.graph);
  };

  List.prototype.filter = function() {
    var file, temp, _i, _len, _ref;
    temp = [];
    _ref = this.graph;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      file = _ref[_i];
      if (__indexOf.call(temp, file) >= 0) {
        this.remove(temp, file);
      }
      temp.push(file);
    }
    return this.graph = temp;
  };

  List.prototype.remove = function(array, value) {
    return array.splice(array.indexOf(value), 1);
  };

  return List;

})();

if ((typeof module !== "undefined" && module !== null) && (module.exports != null)) {
  module.exports.List = List;
}
