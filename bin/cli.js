// Generated by CoffeeScript 1.7.1
(function() {
  var FileFinder, FileScanner, Include, List, Stacker, added, chokidar, f, file, fileFinder, fs, list, path, program, recursive, unadded, watchMaster, watcher, _i, _len,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Include = (function() {
    function Include(required, caller) {
      this.required = required;
      this.caller = caller;
    }

    return Include;

  })();

  if ((typeof module !== "undefined" && module !== null) && (module.exports != null)) {
    module.exports.Include = Include;
  }


  /*
    This class is to compile the Stacked Parser Files
   */

  Stacker = (function() {

    /*
      @property includes [Array<Parser>,Parser] This is the parser files that need to be included
     */
    function Stacker() {
      var inc, includes, _i, _len;
      includes = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (includes instanceof Array) {
        for (_i = 0, _len = includes.length; _i < _len; _i++) {
          inc = includes[_i];
          this.includes = includes;
        }
      }
    }

    Stacker.prototype.includes = [];

    Stacker.prototype.addIncludes = function(more) {
      var file, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = more.length; _i < _len; _i++) {
        file = more[_i];
        _results.push(this.includes.push(file));
      }
      return _results;
    };

    Stacker.prototype.stack = function() {
      var include, list, _i, _len, _ref, _results;
      list = new List();
      _ref = this.includes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        include = _ref[_i];
        _results.push(list.append(include));
      }
      return _results;
    };

    return Stacker;

  })();

  if ((typeof module !== "undefined" && module !== null) && (module.exports != null)) {
    module.exports.Stacker = Stacker;
  }

  fs = require("fs");

  FileScanner = (function() {
    function FileScanner(path, watch) {
      this.path = path;
      this.watch = watch;
      this.files = [];
      this.fileExt = ["coffee"];
      this.fileExt = this.fileExt.join("|");
      this.scan();
    }

    FileScanner.prototype.scan = function() {
      var data;
      data = fs.readFileSync(this.path, {
        encoding: "utf-8"
      });
      this.lines = data.split("\n");
      this.parse();
      return this.complete();
    };

    FileScanner.prototype.parse = function() {
      var line, _i, _len, _ref, _results;
      if (FileScanner.test == null) {
        FileScanner.test = new RegExp("\ *?#include .*");
      }
      _ref = this.lines;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        this.result = FileScanner.test.exec(line);
        if (this.result !== null) {
          _results.push(this.mark(this.result));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    FileScanner.prototype.mark = function(result) {
      var fileWatch;
      FileScanner.resultTest = new RegExp("[^ ]+\.(" + this.fileExt + ")");
      fileWatch = FileScanner.resultTest.exec(result);
      if (fileWatch) {
        return this.files.push(fileWatch[0]);
      }
    };

    FileScanner.prototype.complete = function() {};

    return FileScanner;

  })();

  if ((typeof module !== "undefined" && module !== null) && (module.exports != null)) {
    module.exports.FileScanner = FileScanner;
  }

  fs = require("fs");

  path = require("path");

  FileScanner = require("./FileScanner.js").FileScanner;

  Include = require("./Include.js").Include;

  FileFinder = (function() {
    function FileFinder(path, watch) {
      this.path = path;
      this.watch = watch;
      this.includeStack = [];
      this.exec();
    }

    FileFinder.prototype.exec = function() {
      var e, stats;
      try {
        stats = fs.statSync(this.getAbsolutePath());
        if (stats.isDirectory()) {
          return this.directory();
        } else if (stats.isFile()) {
          return this.file();
        } else {
          throw new Error("No Idea how to Handle file not found");
        }
      } catch (_error) {
        e = _error;
        e = new Error("Files doesn't exist");
        e.required = this.path;
        throw e;
      }
    };

    FileFinder.prototype.file = function() {
      var f, _i, _len, _ref, _results;
      if (this.includeStack == null) {
        this.includeStack = [];
      }
      this.fileScanner = new FileScanner(this.getAbsolutePath(), this.watch);
      _ref = this.fileScanner.files;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        _results.push(this.includeStack.push(new Include(path.resolve(this.getDirectory(this.getAbsolutePath()), f), this.getAbsolutePath())));
      }
      return _results;
    };

    FileFinder.prototype.getDirectory = function(f) {
      return path.dirname(f);
    };

    FileFinder.prototype.getAbsolutePath = function() {
      return path.resolve(this.path);
    };

    FileFinder.prototype.getRelativePath = function() {
      var normal;
      normal = path.normalize(this.path);
      return path.resolve(normal);
    };

    FileFinder.prototype.isAbsolute = function() {
      var absolute, normal;
      normal = path.normalize(this.path);
      absolute = path.resolve(this.path);
      return normal === absolute;
    };

    return FileFinder;

  })();

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    module.exports.FileFinder = FileFinder;
  }

  Stacker = require("./Stacker").Stacker;

  Include = require("./Include").Include;

  List = (function() {
    function List() {
      this.collection = [];
    }

    List.prototype.append = function() {
      var item, parser, _i, _len;
      parser = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      for (_i = 0, _len = parser.length; _i < _len; _i++) {
        item = parser[_i];
        if (item instanceof Stacker) {
          this.appendStack(item);
        } else if (item instanceof Include) {
          this.appendInclude(item);
        }
      }
      return this.build();
    };

    List.prototype.appendStack = function(stack) {
      var inc, _i, _len, _ref, _results;
      _ref = stack.includes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        inc = _ref[_i];
        _results.push(this.appendInclude(inc));
      }
      return _results;
    };

    List.prototype.appendInclude = function(include) {
      var item, safe, _i, _len, _ref;
      safe = true;
      _ref = this.collection;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (item.required === include.required && item.caller === include.caller) {
          safe = false;
        }
      }
      if (safe) {
        return this.collection.push(include);
      }
    };

    List.prototype.build = function() {
      var b, bronze, g, gold, inc, s, silver, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1;
      this.graph = [];
      bronze = [];
      silver = [];
      gold = [];
      _ref = this.collection;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        inc = _ref[_i];
        bronze.push(inc.caller);
      }
      _ref1 = this.collection;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        inc = _ref1[_j];
        silver.push(inc.required);
      }
      for (_k = 0, _len2 = silver.length; _k < _len2; _k++) {
        g = silver[_k];
        if (__indexOf.call(bronze, g) < 0) {
          gold.push(g);
        }
      }
      for (_l = 0, _len3 = bronze.length; _l < _len3; _l++) {
        b = bronze[_l];
        this.graph.push(b);
      }
      for (_m = 0, _len4 = silver.length; _m < _len4; _m++) {
        s = silver[_m];
        this.graph.push(s);
      }
      for (_n = 0, _len5 = gold.length; _n < _len5; _n++) {
        g = gold[_n];
        this.graph.push(g);
      }
      return this.filter();
    };

    List.prototype.filter = function() {
      var file, temp, _i, _len, _ref;
      temp = [];
      _ref = this.graph;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        file = _ref[_i];
        if (__indexOf.call(temp, file) >= 0) {
          this.remove(temp, file);
        }
        temp.push(file);
      }
      return this.graph = temp;
    };

    List.prototype.remove = function(array, value) {
      return array.splice(array.indexOf(value), 1);
    };

    return List;

  })();

  if ((typeof module !== "undefined" && module !== null) && (module.exports != null)) {
    module.exports.List = List;
  }

  chokidar = require('chokidar');

  program = require("commander");

  FileFinder = require("./FileFinder").FileFinder;

  List = require("./List").List;

  fs = require("fs");

  program.version("0.0.1").option("-v, --verbose", "Show messages").option("-w, --watch", "Watch Files").option("-o, --output [value]", "The file to output all files in. eg application.js").parse(process.argv);

  file = [];

  if (program.args) {
    file = program.args;
  }

  list = new List();

  fileFinder = [];

  added = [];

  unadded = [];

  recursive = function(file) {
    var e, f, _i, _len, _ref, _results;
    if (program.verbose) {
      console.log("parsing " + file);
    }
    try {
      fileFinder.push(new FileFinder(file, program.watch));
    } catch (_error) {
      e = _error;
      console.log("in " + file + ", file " + e.required + " doesn't exist");
    }
    _ref = fileFinder[fileFinder.length - 1].includeStack;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      f = _ref[_i];
      _results.push(arguments.callee(f.required));
    }
    return _results;
  };

  process.bundle = function() {
    var bundle, stack, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = fileFinder.length; _i < _len; _i++) {
      bundle = fileFinder[_i];
      _results.push((function() {
        var _j, _len1, _ref, _ref1, _ref2, _results1;
        _ref = bundle.includeStack;
        _results1 = [];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          stack = _ref[_j];
          list.append(stack);
          if (program.watch) {
            if (_ref1 = stack.required, __indexOf.call(added, _ref1) < 0) {
              unadded.push(stack.required);
            }
            if (_ref2 = stack.caller, __indexOf.call(added, _ref2) < 0) {
              _results1.push(unadded.push(stack.caller));
            } else {
              _results1.push(void 0);
            }
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      })());
    }
    return _results;
  };

  process.output = function() {
    var data, i, item, _i, _ref;
    if (!list.graph) {
      console.log("Nothing to output?");
      process.exit(0);
    }
    if (program.verbose) {
      console.log("Outputing...");
    }
    if (program.output) {
      fs.writeFile(program.output, "");
    }
    for (i = _i = _ref = list.graph.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
      item = list.graph[i];
      data = fs.readFileSync(item, {
        "encoding": "utf-8"
      });
      if (program.output) {
        if (program.verbose) {
          console.log("writing file " + item);
        }
        data = data.replace(/# ?include .+/g, "");
        fs.appendFile(program.output, data + "\n");
      } else {
        console.log(data);
      }
    }
    return console.log("wrote to " + program.output + " complete");
  };

  if (file.length === 0) {
    console.log("No Input");
  }

  watchMaster = null;

  watcher = function() {
    var _i, _len;
    if (program.verbose) {
      console.log("watch has been added");
    }
    if (program.watch) {
      for (_i = 0, _len = unadded.length; _i < _len; _i++) {
        file = unadded[_i];
        if (typeof watcthMaster === "undefined" || watcthMaster === null) {
          watchMaster = chokidar.watch(file, {
            persistent: true
          });
          watchMaster.on("change", (function(_this) {
            return function(newfile) {
              recursive(newfile);
              process.bundle();
              return process.output();
            };
          })(this));
        }
        watchMaster.add(file);
        added.push(file);
      }
      unadded = [];
      return watchMaster.close();
    }
  };

  for (_i = 0, _len = file.length; _i < _len; _i++) {
    f = file[_i];
    recursive(f);
  }

  process.bundle();

  process.output();

  watcher();

}).call(this);
