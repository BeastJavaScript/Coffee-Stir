// Generated by CoffeeScript 1.7.1

/*
  This class is the {TestResult} of when a {TestCase} is run. This is stored inside {TestCase.result}
 */
var TestCase, TestResult;

TestResult = (function() {

  /*
    @nodoc
   */
  function TestResult(testClass, name, message, result, position) {
    this.testClass = testClass;
    this.name = name;
    this.message = message;
    this.result = result;
    this.position = position;
    this['class'] = this.testClass;
  }


  /*
    @property [String] The Object name that extended the TestCase Class
   */

  TestResult.prototype.testClass = null;


  /*
    @property [String] The name of the method that was being tested
   */

  TestResult.prototype.name = null;


  /*
    @property [String] The message from the result of the Test
   */

  TestResult.prototype.message = null;


  /*
    @property [Integer] The type of the Result
    @see {TestCase.passed}, {TestCase.warning}, {TestCase.failed}
   */

  TestResult.prototype.result = null;


  /*
  @property [Integer] The position of the assert Function for the specific method being tested
   */

  TestResult.prototype.position = null;

  return TestResult;

})();

if (typeof module.exports !== "undefined") {
  module.exports.TestResult = TestResult;
}


/*
  This class provides an extremely readable testing framework for testing with CoffeeScript and Javascript in General.
  It was built using CoffeeScript.

  You must keep this header in all copy of this Source Code.
  @author Shavauhn Gabay
 */

TestCase = (function() {
  var ready;

  ready = false;


  /*
    @param auto [Boolean] if set to false test will not automatically run. Test can be run with the {TestCase#run} method
    @return [TestCase]
   */

  function TestCase(auto) {
    this.auto = auto != null ? auto : true;
    TestCase.count++;
    if (this.auto) {
      this.run();
    }
  }

  TestCase.count = 0;

  TestCase.result = [];


  /*
  @nodoc
   */

  TestCase.prototype.prepare = function() {
    var property, _results;
    for (property in this) {
      if (property === "base") {
        ready = true;
      }
    }
    _results = [];
    for (property in this) {
      if (property === "reset" && typeof this[reset] === "function") {
        _results.push(ready = ready && true);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };


  /*
    This method is used to run the Test. The test will be executed and the results will be stored inside {TestCase.result} array.
   */

  TestCase.prototype.run = function() {
    var e, property;
    if (typeof TestCase.start_t === "undefined") {
      TestCase.start_t = Date.now();
    } else {
      TestCase.start_t = Math.min(Date.now(), TestCase.start_t);
    }
    this.prepare();
    if (!ready) {
      return;
    }
    for (property in this) {
      if (property.slice(0, 5).toLowerCase() === "_test" || property.slice(0, 4).toLowerCase() === "test") {
        TestCase.testAssert = 1;
        TestCase.currentClassName = this.constructor.name;
        TestCase.currentName = property;
        try {
          this.base();
        } catch (_error) {
          e = _error;
          TestCase.result.push(new TestResult(TestCase.currentClassName, "base", "Exception " + e.constructor.name + ": " + e.message, TestCase.failed, TestCase.testAssert++));
          break;
        }
        try {
          if (this.base() instanceof Array) {
            this[property].apply(this, this.base());
          } else {
            this[property].call(this, this.base());
          }
        } catch (_error) {
          e = _error;
          TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "Exception " + e.constructor.name + ": " + e.message, TestCase.failed, TestCase.testAssert++));
          continue;
        }
      }
    }
    return TestCase.end_t = Date.now();
  };


  /*
    This method will test if the value is equal to true
    @param value [Boolean]
   */

  TestCase.prototype.assertTrue = function(value) {
    if (value === true) {
      return TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "passed", TestCase.passed, TestCase.testAssert++));
    } else {
      return TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "failed to assert false is true", TestCase.failed, TestCase.testAssert++));
    }
  };


  /*
    This will test if two values are equal.
    This will do a deep Object Comparison on Objects and Arrays.
    Be careful of Objects that might contain circular references.
    The Application will handle it just fine but it will result in a warning.
    These Object will not neccesarily be equal
  
    @param test [Object,String,Number,Boolean]
    @param value [Object,String,Number,Boolean]
   */

  TestCase.prototype.assertEquals = function(test, value) {
    if (test instanceof Array && value instanceof Array) {
      return this.assertObjectEquals(test, value);
    }
    if (test instanceof Object && value instanceof Object) {
      return this.assertObjectEquals(test, value);
    }
    if (test === value) {
      return TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "passed", TestCase.passed, TestCase.testAssert++));
    } else {
      return TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "failed to assert \"" + test + "\" equal to \"" + value + "\"", TestCase.failed, TestCase.testAssert++));
    }
  };


  /*
    This will test if an Object is not null
    @param value [Object,String,Number,Boolean]
   */

  TestCase.prototype.assertNotNull = function(value) {
    if (value !== null) {
      return TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "passed", TestCase.passed, TestCase.testAssert++));
    } else {
      return TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "failed to assert " + value + " as not null", TestCase.failed, TestCase.testAssert++));
    }
  };


  /*
    This will test if a value is null
    @param value [Object,String,Number,Boolean]
   */

  TestCase.prototype.assertNull = function(value) {
    if (value === null) {
      return TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "passed", TestCase.passed, TestCase.testAssert++));
    } else {
      return TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "failed to assert " + value + " as null", TestCase.failed, TestCase.testAssert++));
    }
  };


  /*
    This will test if two arrays are equal. This will not do a deep object test on the array. It will only check the first level of the array
    @param array1 [Array]
    @param array2 [Array]
   */

  TestCase.prototype.assertArrayEquals = function(array1, array2) {
    var i, len, _i;
    if (array1.length === array2.length) {
      len = array1.length;
      for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
        if (array1[i] !== array2[i]) {
          TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "failed to assert index " + i + " is equal, \"" + array1[i] + "\" not \"" + array2[i] + "\"", TestCase.failed, TestCase.testAssert++));
        }
      }
      return TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "passed", TestCase.passed, TestCase.testAssert++));
    } else {
      return TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "arrays are not the same value", TestCase.failed, TestCase.testAssert++));
    }
  };


  /*
    This is essential the same as {TestCase#assertEquals}.
    This is just a more reader friendly form that is better at documenting your intention.
    @param obj1 [Object]
    @param obj2 [Object]
   */

  TestCase.prototype.assertObjectEquals = function(obj1, obj2) {
    var e, result;
    try {
      result = this.deepObjectCompare(obj1, obj2);
    } catch (_error) {
      e = _error;
      if (e instanceof RangeError) {
        TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "Warning - Object may have circular reference, may or may not be equal", TestCase.warning, TestCase.testAssert++));
        return;
      } else {
        TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, e.message, TestCase.failed, TestCase.testAssert++));
        return;
      }
    }
    if (!result.passed) {
      TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "failed to assert property[" + result.key + "] is equal, \"" + result.value.test + "\" not \"" + result.value.value + "\"", TestCase.failed, TestCase.testAssert++));
    } else {
      TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "passed", TestCase.passed, TestCase.testAssert++));
    }
  };


  /*
    @nodoc
   */

  TestCase.prototype.deepObjectCompare = function(test, value) {
    var key, result;
    result = {};
    for (key in test) {
      result.key = key;
      result.value = {
        "test": test[key],
        "value": value[key]
      };
      if (typeof test[key] === "object" && typeof value[key] === "object") {
        if (!this.deepObjectCompare(test[key], value[key])) {
          result.passed = false;
          return result;
        }
      } else if (typeof test[key] === "object" && typeof value[key] === "object") {
        if (!this.deepObjectCompare(test[key], value[key])) {
          result.passed = false;
          return result;
        }
      } else if (test[key] !== value[key]) {
        result.passed = false;
        return result;
      }
    }
    result.passed = true;
    return result;
  };


  /*
    This will check if two objects are the same objects. It will also test if two primitives are equal.
    @param test [Object,String,Number,Boolean]
    @param value [Object,String,Number,Boolean]
   */

  TestCase.prototype.assertSame = function(test, value) {
    if (test === value) {
      return TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "passed", TestCase.passed, TestCase.testAssert++));
    } else {
      return TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "failed to assert \"" + test + "\" is the exact same \"" + value + "\"", TestCase.failed, TestCase.testAssert++));
    }
  };


  /*
    This will test if two values are similar. This is mainly for primitive values when comparing a string and a number.
    When used on a object it is essentially the same as {TestCase#assertSame}.
    This will also ignore casing when comparing strings
    @example
      5=='5' #true
      'PizzaMan' == 'pizzaman' #true
    @param test [Object,String,Number,Boolean]
    @param value [Object,String,Number,Boolean]
   */

  TestCase.prototype.assertSimilar = function(test, value) {
    if (typeof test === "string" && typeof value === "string") {
      if (test.toLowerCase() === value.toLowerCase()) {
        TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "passed", TestCase.passed, TestCase.testAssert++));
      } else {
        TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "failed to assert \"" + test + "\" of type [" + (typeof test) + "] is similar to \"" + value + "\" of type [" + (typeof value) + "]", TestCase.failed, TestCase.testAssert++));
      }
      return;
    }
    if (test == value) {
      return TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "passed", TestCase.passed, TestCase.testAssert++));
    } else {
      return TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "failed to assert \"" + test + "\" of type [" + (typeof test) + "] is similar to \"" + value + "\" of type [" + (typeof value) + "]", TestCase.failed, TestCase.testAssert++));
    }
  };


  /*
    This will check if a value is a function. This can be useful with callbacks testing.
    @param func [Function]
   */

  TestCase.prototype.assertFunction = function(func) {
    if (typeof func === "function") {
      return TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "passed", TestCase.passed, TestCase.testAssert++));
    } else {
      return TestCase.result.push(new TestResult(TestCase.currentClassName, TestCase.currentName, "failed to assert value is function, " + func.constructor.name + " was passed", TestCase.failed, TestCase.testAssert++));
    }
  };


  /*
    This will symbolize that a test has passed
   */

  TestCase.passed = 1;


  /*
    This will symbolize that a test has passed but with a warning
   */

  TestCase.warning = 0;


  /*
    This will symbolize that a test has failed
   */

  TestCase.failed = -1.;


  /*
    This can be used to get the HTML Summary of the Results
    @return [String]
   */

  TestCase.getHTMLResult = function() {
    TestCase.nl = "<br/>";
    TestCase.tab = "&nbsp;&nbsp;&nbsp;";
    return TestCase.print();
  };


  /*
    This will get the result but without any HTML code inside the string
    @return [String]
   */

  TestCase.getResult = function() {
    TestCase.nl = "\n";
    TestCase.tab = "\t";
    return TestCase.print();
  };


  /*
   This is used in the print format of {TestCase.getResult} and {TestCase.getHTMLResult}. This value is overwritten each time those functions are run. If you want to add your own spacing for need to overwrite and then call {TestCase.print}
   */

  TestCase.nl = "\n";


  /*
   This is used in the print format of {TestCase.getResult} and {TestCase.getHTMLResult}. This value is overwritten each time those functions are run. If you want to add your own spacing for need to overwrite and then call {TestCase.print}
   */

  TestCase.tab = "\t";


  /*
    This will contain all of the results, after a test has been run
   */

  TestCase.result = [];


  /*
   You can create your own custom print by overwriting {TestCase.format} and changing the {TestCase.nl} and {TestCase.tab} and calling {TestCase.print}
   */

  TestCase.print = function() {
    var failCount, passedCount, result, string, warningCount, _i, _len, _ref;
    failCount = 0;
    warningCount = 0;
    passedCount = 0;
    string = "";
    _ref = TestCase.result;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      result = _ref[_i];
      if (result.result === TestCase.passed) {
        passedCount++;
      } else if (result.result === TestCase.warning) {
        warningCount++;
        string += TestCase.format(result);
      } else if (result.result === TestCase.failed) {
        failCount++;
        string += TestCase.format(result);
      }
    }
    TestCase.total_t = TestCase.end_t - TestCase.start_t;
    TestCase.seconds = parseInt(TestCase.total_t / 1000);
    TestCase.ms = TestCase.total_t % 1000;
    return string += "Test Complete " + passedCount + "/" + TestCase.result.length + " passed, " + warningCount + "/" + TestCase.result.length + " warnings, " + failCount + "/" + TestCase.result.length + " failed" + TestCase.nl + "Total time " + TestCase.seconds + "s " + TestCase.ms + "ms";
  };


  /*
    This method is used to format the code that is generated from the results. You can override this method to create a different format if you want to.
    @param result [TestResult]
    @return [String]
   */

  TestCase.format = function(result) {
    var nl, tab;
    nl = TestCase.nl;
    tab = TestCase.tab;
    if (result.result === TestCase.passed) {
      return "";
    } else if (result.result === TestCase.warning) {
      return "" + result["class"] + "@" + result.name + nl + tab + result.message + ", on assert # " + result.position + nl + nl;
    } else if (result.result === TestCase.failed) {
      return "" + result["class"] + "@" + result.name + nl + tab + result.message + ", on assert # " + result.position + nl + nl;
    }
  };

  return TestCase;

})();

if (typeof module.exports !== "undefined") {
  module.exports.TestCase = TestCase;
}

//# sourceMappingURL=beast.testsuite.map
